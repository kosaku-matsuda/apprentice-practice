# Rubyでフィボナッチの解説を数学の理解が薄い人でもわかるよう説明してみた。

## はじめに
rubyの学習をしていてかなり詰まったところなので
忘れないよう学習の軌跡として残します。
なお、数学が苦手な人のためにもなるべく用語などは使わず
直感的にわかるように説明していきます。
まだまだプログラミングは始めたてで間違っていたり、見ずらかったりしてしまったら申し訳ありません。
ご指摘など頂けますと幸いです。

## 目次
- フィボナッチ数列とは
- プログラムにしてみる
- 実際に問題を解いてみる

## フィボナッチ数列とは
まず、はじめにフィボナッチ数列がどういうものかを説明します。

フィボナッチ数列」とは、「1、1、2、3、5、8、13、21、34、55、89、144、233…」と続く数列のことです。 パッと見た感じ、不規則に数字が並んでいるように見えますが、実は法則が存在します。 それは「前の2つの項同士を足した数」という法則です。

例えば、まず最初が1であれば前の数字がないので
1+0は1
次に最初の1とさっき計算した1を足して
1+1は2
といったように前の数字と前々の数字を足していくと
1, 1, 2, 3, 5, 8
のように法則に則って数列ができていきます。
これがフィボナッチ数列です。

なのでフィボナッチ数列というのは第何項は〇〇と数値が法則により決まっています。
初項 = 1、第２項 = 1、第３項以降は、前項と前々項の和となる数列です
第３項は初項と第２項の和なので「1+1」で"2"となります
第４項は第２項と第３項の和なので"3"となります
数列としては、「1(初項),1(第２項),2(第３項),3(第4項),5,8,13,21,34,55,・・・」と続きます


この数列の第n項目は何になるかを次の章で求めたいと思います。


##　プログラムにしてみる
先程の法則を踏まえてプログラムにしてみてみます。

```ruby

fib(n) = fib(n-2) + fib(n-1)
# 第n項 = 第n項から2を引いたもの　と　第n項から1を引いたものを足すと表せます。

例えば下記のように4とした場合、fib(4-2=2) + fib(4-1=3)となるのでこういう風に置き換えれます。
fib(4) = fib(2) + fib(3)
これを訳すと

『fibのインデックス４番目にはfibのインデックス２番目の数字と3番目の数字を足したものを入れましょう。』

fib = [1,1,2,n],
fibの２番目は1です。
fibの3番目は2です。
つまり第4項はこれらを足した"3"ということになります。

fib(4) = 3

なぜ fib(n-2) + fib(n-1)とするかわからない方のために説明すると
1, 1, 2, 3, 5, 8....
という数列にフィボナッチ数列がなることを説明しました。

nには4を入れたので第４項は3です。
３は前の第３項の2と第２項の1を足したものです。
fib(n-2) + fib(n-1)はnに第4項の4が入るので
上の式を使うと自ずと第3項+第２項となるのです。
nに他の数値を当てはめても同じ事になるので是非やってみてください。


```


これらを理解したところで実際に関数にして
フィボナッチ数列では第n項は何の数字が当てはまるのかを
調べる機能を作ってみましょう。

## 実際に問題を解いてみる


***問題***

家のお手伝いを毎日継続すると、継続日数 n 日に応じて、その日にもらえるお小遣いの金額が増えていきます。お小遣いの金額は以下の条件に従ってもらうことができます。

f(0) = 0 円 f(1) = 1 円 f(n) = f(n-1) + f(n-2) 円 (n ≧ 2)

整数 n に対して、n 日間お手伝いを継続した時のお小遣いの金額を算出する関数 fibonacci を定義してください。

この問題をプログラムにすると以下になります。

```ruby

def fibonacci(n)
  if n == 0
    return 0
  elsif n == 1
    return 1
  else
    fib = [0, 1]
    (2..n).each do |i|
      fib[i] = fib[i-1] + fib[i-2]
    end
    return fib[n]
  end
end
```

見にくいかもですがどういう処理が行われてるかを細かく書いて見ました。

```ruby
def fibonacci(n)
  if n == 0
    return 0
    # 0日目は０円だから継続していないので0をそのまま返す。
  elsif n == 1
    return 1
    # １日目だと１円だから継続していないので1をそのまま返す。
  else
    # 1日以上なのでelseで再起処理を行う
    # 例えばnに2を入れた二日目の場合、昨日の金額が1円で一昨日が0円なので０+1で二日目も1円となる
    # fibという配列変数を作り０日目と１日目を先に格納しておく
    # 何故(２..n)と２からなのかは0日目と１日目は０円と1円ともう上で定義しており、2日目からを計算するから
    # nにはfibonacci(n)の任意の何日働いたかを表す数字が入ってくるつまり第何項か、それをeachでiに渡して順番に処理を行なっていく。
    fib = [0, 1]
    (2..n).each do |i|
      fib[i] = fib[i-1] + fib[i-2]
      # eachでfib[i]は最初fibの２..nの２から始まるためfib[2]つまりfibの配列のインデックス二番目には
      # fib[i-1] + fib[i-2](2-1 + 2-2 = 1)は１となります。
      #　今こういう状態 fib = [0, 1, 1] ← fibのインデックス２番に1が格納された。
      # 次にeachで3が回ってくるのでfib[3]にfib[2]さっき格納した1そのあとfib[3-2=1]だから1+1で2だからfib[3]には2が入る。
      # fib[4]にfib[4-1]つまりさっき格納したfib[3](2) + fib[4-2]つまりfib[2](1)に格納した1 2+1 の3がfib[4]には格納される
    end
    return fib[n]
  end
end
```





